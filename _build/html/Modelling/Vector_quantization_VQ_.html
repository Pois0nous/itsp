
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vector quantization (VQ) &#8212; Introduction to Speech Processing</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Introduction to Speech Processing</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../README.html">
   Introduction to Speech Processing
  </a>
 </li>
</ul>
    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/Modelling/Vector_quantization_VQ_.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metric-for-codebook-quality">
   Metric for codebook quality
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#codebook-optimization">
   Codebook optimization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algorithmic-complexity">
   Algorithmic complexity
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#applications">
   Applications
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discussion">
   Discussion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#attachments">
   Attachments:
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Vector quantization (VQ)</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#metric-for-codebook-quality">
   Metric for codebook quality
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#codebook-optimization">
   Codebook optimization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algorithmic-complexity">
   Algorithmic complexity
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#applications">
   Applications
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#discussion">
   Discussion
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#attachments">
   Attachments:
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="vector-quantization-vq">
<h1>Vector quantization (VQ)<a class="headerlink" href="#vector-quantization-vq" title="Permalink to this headline">Â¶</a></h1>
<div class="contentLayout2">
<div class="columnLayout two-equal" layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p>Suppose you have recorded sounds at different locations and want to
categorize them into similar groups. In other words, you have a
stochastic vectorÂ <em>x</em> which you want to characterize with a simple
description. For example, categories could correspond to office, street,
hallway and cafeteria. A classic way for this task is to choose template
vectors <em>c<sub>k</sub></em>, which represents a typical sound in each
environment <em>k</em>. To categorize the sounds, you then find that template
vector which is closest to your recordingÂ <em>x</em>. In mathematical notation,
you search for aÂ <em>k<sup>*</sup></em>Â by</p>
<p>\[ k^* = \arg\min_k \|x-c_k\|^2. \]</p>
<p>The above expression thus calculates the squared error betweenÂ *xÂ *and
each of the vectorsÂ <em>c<sub>k</sub></em>Â and chooses the index *kÂ *of the
vector with the smallest error. The vectorsÂ <em>c<sub>k</sub></em>Â then
represent a codebook and the vectorÂ <em>x</em> is quantized to
<em>c<sub>k*</sub></em>. This is the basic idea behindÂ <em>vector quantization,</em>
which isÂ also known asÂ <em>k-means</em>.</p>
<p>A illustration of a simple vector codebook is shown on the right. The
input data is a Gaussian distribution shown with grey dots and the
codebook vectors <em>c<sub>k</sub></em> with red circles. For each input vector
we thus search for the nearest codebook vector and the borders of the
regions where input vectors are assigned to a particular codebook vector
are illustrated with blue lines. These regions are known as <a class="reference external" href="https://en.wikipedia.org/wiki/Voronoi_diagram">Voronoi
regions</a> and the blue
lines are the decision-boundaries between codebook vectors.</p>
</div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p><img src="attachments/149883153/175511825.png"
data-image-src="attachments/149883153/175511825.png"
data-unresolved-comment-count="0" data-linked-resource-id="175511825"
data-linked-resource-version="1" data-linked-resource-type="attachment"
data-linked-resource-default-alias="vq.png"
data-base-url="https://wiki.aalto.fi"
data-linked-resource-content-type="image/png"
data-linked-resource-container-id="149883153"
data-linked-resource-container-version="25" height="250" /></p>
<p>Example of a codebook for a 2D Gaussian with 16 code vectors.</p>
</div>
</div>
</div>
<div class="columnLayout two-equal" layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<div class="section" id="metric-for-codebook-quality">
<h2>Metric for codebook quality<a class="headerlink" href="#metric-for-codebook-quality" title="Permalink to this headline">Â¶</a></h2>
<p>Suppose then that you have a large collection of
vectorsÂ <em>x<sub>h</sub></em>, and you want to find out how well this codebook
represents the input data. The expectation of the squared error is
approximately the mean over your data, such that</p>
<p>\[ E_h\left[ \min_k \|x_h-c_k\|^2 \right] \approx \frac 1N
\sum_{h=1}^N \min_k \|x_h-c_k\|^2, \]</p>
<p>where <em>E[ ]</em> is the expectation operator andÂ <em>N</em> is the number of
input vectorsÂ <em>x<sub>h</sub></em>. Above, we thus find the codebook vector
which is closest toÂ <em>x<sub>h</sub></em>, find its squared error and take the
expectation over all possible inputs. This is approximately equal to the
mean of those squared errors over a set of input vectors.</p>
<p>To find the best set of codebook vectors <em>c<sub>k</sub></em>, we then need
to minimize the mean squared error as</p>
<p>\[ \{c_k^*\} := \arg\min_{\{c_k\}}\, E_h\left[ \min_k
\|x_h-c_k\|^2 \right]Â  \]</p>
<p>or more specifically, for a dataset as</p>
<p>\[ \{c_k^*\} := \arg\min_{\{c_k\}} \sum_{h=1}^N \min_k
\|x_h-c_k\|^2. \]</p>
<p>Unfortunately we do not have an analytic solution for this optimization
problem, but have to use numerical, iterative methods.</p>
</div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
</div>
</div>
<div class="columnLayout two-equal" layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
<div class="section" id="codebook-optimization">
<h2>Codebook optimization<a class="headerlink" href="#codebook-optimization" title="Permalink to this headline">Â¶</a></h2>
<p>Most methods for finding the best codebook are derivatives of
expectation maximization (EM), which is based on two alternating steps:</p>
<p><em>Expectation Maximation (EM)</em> algorithm:</p>
<ol class="simple">
<li><p>For every vector <em>x<sub>h</sub></em> in a large database, find the best
codebook vector <em>c<sub>k</sub></em>.</p></li>
<li><p>For every codebook vector <em>c<sub>k</sub></em>;</p>
<ol class="simple">
<li><p>Find all vectors <em>x<sub>h</sub></em> assigned to that codevector.</p></li>
<li><p>Calculate mean of those vectors.</p></li>
<li><p>Assign the mean as a new value for the codevector.</p></li>
</ol>
</li>
<li><p>If converged then stop, otherwise go to 1.</p></li>
</ol>
<p>This algorithm is guaranteed to give a codebook at every step which is
<em>not worse</em> than the previous codebook. That is, at each iteration will
improve until it finds a local minimum, where it stops changing. The
reason is that each step in the iteration finds a partial best-solution.
In the first step, we find the best matching codebook vectors for each
data vectors <em>x<sub>h</sub></em>. In the second step, we find the
within-category mean. That is, the new mean is more accurate than the
previous codevector in that it reduces the average squared error. If the
mean is equal to the previous codevector, then there is no improvement.</p>
<p>As noted above, this algorithm is the basis to most vector quantization
codebook optimization algorithms. There are a multiple reasons why this
simple algorithm is usually not sufficient alone. Most importantly, the
above algorithm is slow to converge to a stable solution <em>and</em> it often
finds a local minimum instead of a global minimum.</p>
<p>To improve performance, we can apply several heuristic approaches. For
example, we can start with a small codebook \( \{ c_k \}_{k=1}^K \)
of <em>K</em> elements and optimize it with the EM algorithm. We then split the
codebook into two, offset by a small delta <em>d</em>, such that \(
\|d\|&lt;\epsilon \) and make the new codebook \( \{ \hat c_k
\}_{k=1}^{2K} := \{ c_k,\, c_k+d \}_{k=1}^K \) of 2<em>K</em> elements.
We then rerun the EM algorithm on the new codebook. The codebook thus
doubles in size at every iteration and we continue until we have the
desired codebook size.</p>
<p>The advantage of this approach is that it focuses attention to the big
bulk of datapoints <em>x<sub>k</sub></em>, and ignores outliers. The outcome is
then expected to be more stable and the likelihood of converging to a
local minimum is smaller. The downside is that with this approach it is
then more difficult to find small separated islands. That is, because
the initial codebook is near the center of the whole mass of datapoints,
adding a small delta to the codebook vectors keeps the new codevectors
near the center-of-mass.</p>
<p>Conversely, we can start with a large codebook, say treat the whole
input database <em>x<sub>k</sub></em> as a codebook. We can then iteratively
merge pairs of points which are close to each other, until the codebook
is reduced to the desired size. Needless to say, this will be a slow
process if the database is large, but will be very efficient in finding
separated islands of points.</p>
<p>In any case, optimization of vector codebooks is a difficult task and we
have no practical algorithms which would be guaranteed to find the
global optimum. Like in many other machine learning problems, optimizing
the codebook is very much about learning to know your data. You should
first use one algorithm and then analyse the output to find out what can
be improved, and keep repeating this optimization and analyse process
until the output is sufficiently good.</p>
</div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
</div>
</div>
<div class="columnLayout two-equal" layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
<div class="section" id="algorithmic-complexity">
<h2>Algorithmic complexity<a class="headerlink" href="#algorithmic-complexity" title="Permalink to this headline">Â¶</a></h2>
<p>Vector quantization is manageable for relatively small codebooks of,
say, <em>K=32</em> codevectors. That corresponds to 5 bits of information. For
many applications, that does not give sufficient accuracy - the mean
squared error is too large. For example, the linear predictive models in
speech coding could be quantized with 30 bits, which corresponds to \(
K=2^{30}\approx 10^9 \) codevectors. To find the best codevector for a
vector <em>x</em> of length <em>N=16</em>, we would then need to calculate the
distance between every codebook vector and <em>x</em>, which amounts to
approximately \( 16\times10^9= 1.6\times10^{10} \) operations. That
is infeasible in on-line applications on mobile devices. Instead, we
need to find a simpler method which retains the best aspects of the
algorithm, but reduces algorithmic complexity.</p>
<p>A heuristic approach is to use successive codebooks, where at each
iteration, we quantize the error of the last iteration. That is, letâs
say that on the first iteration we have 8 bits, corresponding to a
codebook <em>c<sub>k</sub></em> of <em>K=256</em> vectors. We find the best matching
codevector <em>c<sub>k*</sub></em> and calculate the residual \(
xâ:=x-c_{k*} \) . In the second stage, we would then find the best
matching vector for <em>xâ</em> from a second codebook <em>c<sub>k</sub>â</em>. We can
add as many layers of codebooks as we want until the desired number of
bits has been consumed. This approach is known as a <em>multi-stage vector
quantizer</em>.</p>
<p>Where ordinary vector quantization can find the optimal solution, split
vector quantization generally does not give a global optimum. It does
give good solutions, though, but with an algorithmic complexity which
very much lower than ordinary vector quantization. For example, in the
above example of 30 bits, we could assign three consecutive layers of
codebooks with 10 bits /Â <em>K=1024</em> each, such that the overall complexity
is \( 3\times 16\times 2^{10} \approx 5\times10^4, \) which gives
an improvement with a factor of \( 3.5\times10^5. \) Given that the
reduction in accuracy is manageable, this is a major improvement in
complexity.</p>
</div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
</div>
</div>
<div class="columnLayout two-equal" layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
<div class="section" id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">Â¶</a></h2>
<p>Probably the most important application where vector quantization is
used in speech processing, is <span class="xref myst">speech
coding</span> with <span class="xref myst">Code-excited
linear prediction (CELP)</span>, where</p>
<ul class="simple">
<li><p><span class="xref myst">linear predictive coefficients (LPC)</span> are
transformed to line spectral frequencies (LSFs), which are often
encoded with multi-stage vector quantizers.</p></li>
<li><p>gains (signal energy) of the residual and long term prediction are
jointly encoded with a single stage vector quantizer.</p></li>
</ul>
<p>Other typical applications include</p>
<ul class="simple">
<li><p>In optimization of <a class="reference internal" href="Gaussian_mixture_model_GMM_.html"><span class="doc std std-doc">Gaussian mixture models
(GMMs)</span></a>, it is useful to use vector
quantization to find a first-guess of the means of each mixture.</p></li>
</ul>
</div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
</div>
</div>
<div class="columnLayout two-equal" layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
<div class="section" id="discussion">
<h2>Discussion<a class="headerlink" href="#discussion" title="Permalink to this headline">Â¶</a></h2>
<p>The benefit of vector quantization is that it is a simple algorithm
which gives high accuracy. In fact, for quantizing complicated data,
vector quantization is (in theory) optimal in fixed-rate coding
applications. It is simple in the sense that an experienced engineer can
implement it in a matter of hours. Downsides with vector quantization
include</p>
<ul class="simple">
<li><p>Complexity; for accurate quantization you need prohibitively large
codebooks. The method therefore does not scale up nicely to big
problems.</p></li>
<li><p>Difficult optimization;</p>
<ul>
<li><p>Training data; The amount of data needed to optimize a vector
codebook is large. Each codebook vector must be assigned to a
large number of data vectors, such that calculation of the mean
(in the EM algorithm) is meaningful.</p></li>
<li><p>Convergence; we have no assurance that optimization algorithms
find the global optimum and we have no assurance that local
minima are âgood enoughâ.</p></li>
</ul>
</li>
<li><p>Lack of flexibility; the codebook has a fixed size. If we would like
to use codebooks of different sizes, for example, if we want to
transmit data with a variable bit-rate, then we have to optimize and
store a large codebook for <em>every possible bitrate</em>.</p></li>
<li><p>Blindness to inherent structures; this model describes data with a
codebook, without any deeper understanding of what the data looks
like within each category. For example, say we have two classes,
speech and non-speech. Even if speech is very flexible, the
non-speech class is much, much larger. Speech is a very small subset
of all possible sounds. Therefore, the within-class variance will be
much larger in the non-speech class. Consequently, the accuracy in
the non-speech class would be much lower.<br />
As a consequence, we would be tempted to increase the number of
codevectors such that we get uniform accuracy in both classes. But
then we loose the correspondence between codevectors and natural
descriptions of the signal.</p></li>
</ul>
</div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
</div>
</div>
</div>
</div>
<div class="pageSectionHeader">
</div>
<div class="section" id="attachments">
<h2>Attachments:<a class="headerlink" href="#attachments" title="Permalink to this headline">Â¶</a></h2>
</div>
<div class="greybox" align="left">
<img src="images/icons/bullet_blue.gif" width="8" height="8" />
[vq.png](attachments/149883153/175511825.png) (image/png)  
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Modelling"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Tom BÃ¤ckstrÃ¶m, Okko RÃ¤sÃ¤nen, Abraham Zewoudie, Pablo PÃ©rez Zarazaga, Liisa Koivusalo, Sneha Das<br/>
    
      <div class="extra_footer">
        <p>
<img src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" style="border-width: 0;" alt="Creative Commons License" />
This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
</p>

      </div>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>